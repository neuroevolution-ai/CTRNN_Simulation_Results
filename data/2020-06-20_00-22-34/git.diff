diff --git a/configurations/default.json b/configurations/default.json
index 45a70b0..1ad3f50 100644
--- a/configurations/default.json
+++ b/configurations/default.json
@@ -1,12 +1,12 @@
 {
-  "environment": "LunarLander-v2",
+  "environment": "Ant-v2",
   "random_seed": 0,
-  "number_generations": 50,
+  "number_generations": 300,
   "use_worker_processes": true,
   "optimizer": {
     "type": "MU_ES",
     "hof_size": 10,
-    "n_species": 7,
+    "n_species": 10,
     "checkpoint_frequency": 10,
     "initial_gene_range": 2,
     "mate_indpb": 0.3,
@@ -16,13 +16,13 @@
     "mutation_Gaussian_indpb_1": 0.1,
     "mutation_Gaussian_indpb_2": 0.007,
     "elitist_ratio": 0.0,
-    "tournsize": 4,
-    "mu": 10,
+    "tournsize": 5,
+    "mu": 20,
     "mu_mixed": 0,
     "mu_mixed_base": 0,
     "mu_novel": 0,
     "extra_from_hof": 0,
-    "lambda_": 30,
+    "lambda_": 40,
     "mutpb": 0.8,
     "include_parents_in_next_generation": true,
     "keep_seeds_fixed_during_generation": true,
@@ -33,7 +33,7 @@
   },
   "brain": {
     "type": "CTRNN",
-    "number_neurons": 8,
+    "number_neurons": 30,
     "neuron_activation": "relu",
     "neuron_activation_inplace": false,
     "use_bias": true,
@@ -55,7 +55,7 @@
   },
   "episode_runner": {
     "keep_env_seed_fixed_during_generation": true,
-    "number_fitness_runs": 3,
+    "number_fitness_runs": 2,
     "max_steps_per_run": 0,
     "max_steps_penalty": 0,
     "reuse_env": true,
diff --git a/neuro_evolution_ctrnn/tools/algorithms.py b/neuro_evolution_ctrnn/tools/algorithms.py
index 5f0a4fb..6b6ba72 100644
--- a/neuro_evolution_ctrnn/tools/algorithms.py
+++ b/neuro_evolution_ctrnn/tools/algorithms.py
@@ -13,12 +13,14 @@ from collections import namedtuple
 from typing import Any, List
 import attr
 import logging
+import math
 
 
 @attr.s(slots=True, auto_attribs=True)
 class Species:
     population: Iterable[Any]
     max_fitness: float
+    max_fitness_last: float
     generation_since_new_max: int
     avg_dist: float
     age: int
@@ -46,12 +48,8 @@ def eaMuPlusLambda(toolbox, ngen, verbose=__debug__,
         for idx, ind in enumerate(total_population):
             if clustering_labels[idx] == species_number:
                 population.append(ind)
-        avg_dist = 0
-        for dist in pdist(np.array(population), 'euclidean'):
-            avg_dist += dist
-        avg_dist = avg_dist / len(population)
-        species_list.append(
-            Species(population=population, max_fitness=-10e10, generation_since_new_max=0, age=0, avg_dist=avg_dist))
+
+        species_list.append(species_from_pop(population))
 
     for gen in range(toolbox.initial_generation, ngen + 1):
         nevals = 0
@@ -112,6 +110,7 @@ def eaMuPlusLambda(toolbox, ngen, verbose=__debug__,
                               toolbox.select(candidates, toolbox.conf.mu_novel, fit_attr="novelty")
 
             max_fitness = max(map(lambda x: x.fitness, s.population)).values[0]
+            s.max_fitness_last = max_fitness
             if max_fitness > s.max_fitness:
                 s.max_fitness = max_fitness
                 s.generation_since_new_max = 0
@@ -120,22 +119,35 @@ def eaMuPlusLambda(toolbox, ngen, verbose=__debug__,
             s.age += 1
             s.avg_dist = np.average(pdist(np.array(s.population)))
 
-        # species_list = sorted(species_list, key=lambda x: x.max_fitness)
-        if len(species_list) >= toolbox.conf.n_species:
-            target = None
-            targets = list(filter(lambda x: x.age > 5, species_list))
-            if targets:
-                target = min(targets, key=lambda x: x.max_fitness)
-            if target:
-                logging.debug("removing weak species, id: " + str(target.id) + ", max_fit: "+ str(target.max_fitness))
-                species_list.remove(target)
+        # removing at least 2 must be possible,
+        # because otherwise bad species split faster than they get removed
+        while len(species_list) >= toolbox.conf.n_species - 2:
+            # agressively remove weak or stale species
+            target_weak = min(species_list, key=lambda x: x.max_fitness)
+            target_stale = max(species_list, key=lambda x: x.generation_since_new_max)
+            if target_stale.generation_since_new_max > 8:
+                logging.debug("removing stale species, id: " + str(target_stale.id)
+                              + ", generation_since_new_max: " + str(target_stale.generation_since_new_max))
+                species_list.remove(target_stale)
+            elif target_weak.age > 3:
+                logging.debug("removing weak species, id: " + str(target_weak.id)
+                              + ", max_fit: " + str(target_weak.max_fitness))
+                species_list.remove(target_weak)
+            else:
+                break
+
         if len(species_list) < toolbox.conf.n_species:
 
-            candidates = list(filter(lambda x: x.age > 5, species_list))
             # only split if species hat time to weed out unviable individuals
+            candidates = list(filter(lambda x: x.age > 3, species_list))
+
+            # only split if species has viable fitness
+            candidates = sorted(candidates, key=lambda x: x.max_fitness)[:math.ceil(len(candidates) * 0.5)]
             if candidates:
                 split_this = max(candidates, key=lambda x: x.avg_dist)
-                logging.debug("splitting species, id: "+ str(split_this.id))
+                logging.debug("splitting species, id: " + str(split_this.id) + " into " + str(
+                    Species._instance_count + 1) + " and " + str(Species._instance_count + 2
+                                                                 ))
                 clustering_labels = AgglomerativeClustering(n_clusters=2).fit_predict(split_this.population)
                 pop1 = []
                 pop2 = []
@@ -153,7 +165,7 @@ def eaMuPlusLambda(toolbox, ngen, verbose=__debug__,
             total_population += s.population
         record = toolbox.stats.compile(total_population) if toolbox.stats is not None else {}
 
-        best_s = max(species_list, key=lambda x: x.avg_dist)
+        best_s = max(species_list, key=lambda x: x.max_fitness_last)
 
         toolbox.logbook.record(gen=gen, nevals=nevals, best_species=best_s.id, **record)
         if verbose:
@@ -172,7 +184,7 @@ def species_from_pop(population):
         avg_dist += dist
     avg_dist = avg_dist / len(population)
     return Species(population=population, max_fitness=-10e10, generation_since_new_max=0, age=0,
-                   avg_dist=avg_dist)
+                   avg_dist=avg_dist, max_fitness_last=-10e10)
 
 
 def calc_novelty(res, results_recorded, get_distance, k):
diff --git a/neuro_evolution_ctrnn/tools/experiment.py b/neuro_evolution_ctrnn/tools/experiment.py
index 5374e0e..0d300e4 100644
--- a/neuro_evolution_ctrnn/tools/experiment.py
+++ b/neuro_evolution_ctrnn/tools/experiment.py
@@ -116,7 +116,9 @@ class Experiment(object):
         print("Done")
 
     def visualize(self, individuals, brain_vis_handler, rounds_per_individual=1, neuron_vis=False, slow_down=0):
-        env = make_env(self.config.environment)
+        env_handler = EnvHandler(self.config.episode_runner)
+
+        env = env_handler.make_env(self.config.environment)
         env.render()
         if hasattr(self.config.optimizer, "mutation_learned"):
             # sometimes there are also optimizing strategies encoded in the genome. These parameters
